<!DOCTYPE html>
<html lang="es">
<head>

<!-- 
  ===============================================
  PERSONAL 2FA - STANDALONE VERSION
  ===============================================
  
  This is a self-contained file that includes:
  - All HTML, CSS, and JavaScript
  - No external dependencies
  - Works offline
  - Completely portable
  
  Security Features:
  - AES-256-GCM encryption
  - PBKDF2 key derivation (100,000 iterations)
  - Web Crypto API for hardware acceleration
  - IndexedDB for encrypted local storage
  - No network connections
  
  Usage:
  1. Save this file to your computer
  2. Open in a modern browser (Chrome, Firefox, Safari, Edge)
  3. Create master password on first run
  4. Import from Google Authenticator or add manually
  5. Export QR codes for backup (not stored in app)
  
  File size: 92.40 KB
  Build date: 2025-10-26T08:43:25.968Z
  
  ‚ö†Ô∏è IMPORTANT SECURITY NOTES:
  - Only use on HTTPS or localhost for camera access
  - Verify code integrity before use
  - Keep master password secure
  - Make encrypted backups regularly
  
  ===============================================
-->

<!-- 
  Personal 2FA - Secure Local Authenticator
  Build: 2025-10-26T08:43:25.844Z
  Version: 1.0.0
  
  Security Notice:
  - This app works 100% offline
  - All data is encrypted locally
  - No external connections
  - Code is readable and inspectable
-->
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Personal 2FA - Secure Local Authenticator</title>
  <style>
/**
 * Personal 2FA - Styles
 * Build: 2025-10-26T08:43:25.859Z
 * Mobile-first responsive design
 */

/**
 * Personal 2FA - Secure Local 2FA Application
 * Styles for mobile-first responsive design
 */

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
  min-height: 100vh;
  color: #333;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 20px;
}

/* Security Header */
.security-header {
  background: rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(10px);
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
  padding: 15px 0;
  position: sticky;
  top: 0;
  z-index: 100;
}

.security-header .container {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 10px;
}

.security-header h1 {
  color: white;
  font-size: 1.5rem;
  font-weight: 600;
}

.security-indicators {
  display: flex;
  gap: 15px;
  flex-wrap: wrap;
}

.indicator {
  background: rgba(255, 255, 255, 0.2);
  color: white;
  padding: 5px 12px;
  border-radius: 20px;
  font-size: 0.8rem;
  font-weight: 500;
}

/* Main App Container */
.app-container {
  max-width: 800px;
  margin: 20px auto;
  padding: 0 20px;
}

/* Screen Management */
.screen {
  display: none;
}

.screen.active {
  display: block;
}

/* Cards */
.setup-card,
.login-card {
  background: white;
  border-radius: 15px;
  padding: 30px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
  margin: 40px auto;
  max-width: 500px;
}

.setup-card h2,
.login-card h2 {
  text-align: center;
  margin-bottom: 20px;
  color: #2a5298;
}

/* Security Notice */
.security-notice {
  background: #e8f5e8;
  border: 2px solid #4caf50;
  border-radius: 10px;
  padding: 20px;
  margin: 20px 0;
}

.security-notice h3 {
  color: #2e7d32;
  margin-bottom: 10px;
}

.security-notice ul {
  color: #2e7d32;
  line-height: 1.6;
  list-style: none;
}

/* Form Styles */
.password-setup {
  margin-top: 20px;
}

.password-setup label {
  display: block;
  margin-bottom: 5px;
  font-weight: 600;
  color: #555;
}

input[type="text"],
input[type="password"],
input[type="number"],
select {
  width: 100%;
  padding: 12px 15px;
  border: 2px solid #ddd;
  border-radius: 8px;
  font-size: 16px;
  margin-bottom: 15px;
  transition: border-color 0.3s ease;
}

input:focus,
select:focus {
  outline: none;
  border-color: #2a5298;
  box-shadow: 0 0 0 3px rgba(42, 82, 152, 0.1);
}

/* Buttons */
.btn-primary,
.btn-secondary,
.btn-action {
  padding: 12px 24px;
  border: none;
  border-radius: 8px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  display: inline-block;
  text-decoration: none;
}

.btn-primary {
  background: #2a5298;
  color: white;
}

.btn-primary:hover {
  background: #1e3c72;
  transform: translateY(-2px);
}

.btn-secondary {
  background: #6c757d;
  color: white;
}

.btn-secondary:hover {
  background: #5a6268;
}

.btn-action {
  background: #28a745;
  color: white;
  margin: 5px;
}

.btn-action:hover {
  background: #218838;
}

/* Action Bar */
.action-bar {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 10px;
  margin-bottom: 30px;
  padding: 20px;
  background: white;
  border-radius: 15px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
}

/* Sections */
.section {
  background: white;
  border-radius: 15px;
  padding: 25px;
  margin-bottom: 20px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
}

.section h3 {
  color: #2a5298;
  margin-bottom: 20px;
  font-size: 1.3rem;
}

.section.hidden {
  display: none;
}

/* QR Scanner */
.qr-scanner {
  text-align: center;
  margin: 20px 0;
}

#qr-video {
  width: 100%;
  max-width: 400px;
  border-radius: 10px;
  border: 3px solid #2a5298;
}

.scan-status {
  margin-top: 15px;
  padding: 10px;
  border-radius: 8px;
  background: #f8f9fa;
}

/* Export Section */
.export-notice {
  background: #fff3cd;
  border: 2px solid #ffc107;
  border-radius: 10px;
  padding: 15px;
  margin-bottom: 20px;
  color: #856404;
}

.export-options {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.export-result {
  margin-top: 20px;
  text-align: center;
}

/* TOTP Codes */
.totp-list {
  display: grid;
  gap: 15px;
}

.totp-item {
  background: #f8f9fa;
  border: 2px solid #dee2e6;
  border-radius: 12px;
  padding: 20px;
  transition: all 0.3s ease;
}

.totp-item:hover {
  border-color: #2a5298;
  box-shadow: 0 5px 15px rgba(42, 82, 152, 0.1);
}

.totp-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.totp-service {
  font-weight: 600;
  color: #2a5298;
  font-size: 1.1rem;
}

.totp-account {
  color: #6c757d;
  font-size: 0.9rem;
}

.totp-code {
  font-family: 'Courier New', monospace;
  font-size: 2rem;
  font-weight: bold;
  color: #28a745;
  text-align: center;
  letter-spacing: 3px;
  margin: 15px 0;
  cursor: pointer;
  user-select: all;
}

.totp-timer {
  display: flex;
  align-items: center;
  gap: 10px;
}

.timer-progress {
  flex: 1;
  height: 8px;
  background: #e9ecef;
  border-radius: 4px;
  overflow: hidden;
}

.timer-bar {
  height: 100%;
  background: linear-gradient(90deg, #28a745, #ffc107, #dc3545);
  transition: width 1s linear;
}

.timer-text {
  font-size: 0.9rem;
  font-weight: 600;
  color: #6c757d;
}

/* Manual Add Form */
.advanced-options {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 15px;
  margin: 20px 0;
  padding: 20px;
  background: #f8f9fa;
  border-radius: 10px;
}

.advanced-options label {
  display: flex;
  flex-direction: column;
  gap: 5px;
  font-size: 0.9rem;
}

.form-actions {
  display: flex;
  gap: 10px;
  justify-content: center;
}

/* Empty State */
.empty-state {
  text-align: center;
  padding: 40px 20px;
  color: #6c757d;
}

.empty-state p {
  margin-bottom: 10px;
}

/* Security Panel (Development) */
.security-panel {
  position: fixed;
  bottom: 10px;
  right: 10px;
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 15px;
  border-radius: 10px;
  font-size: 0.8rem;
  max-width: 300px;
  z-index: 1000;
}

.security-panel h4 {
  margin-bottom: 10px;
  color: #28a745;
}

/* Error Messages */
.error-message {
  background: #f8d7da;
  color: #721c24;
  padding: 10px;
  border-radius: 5px;
  margin-top: 10px;
  display: none;
}

.error-message.show {
  display: block;
}

/* Success Messages */
.success-message {
  background: #d4edda;
  color: #155724;
  padding: 10px;
  border-radius: 5px;
  margin-top: 10px;
}

/* Hidden utility */
.hidden {
  display: none !important;
}

/* Responsive Design */
@media (max-width: 768px) {
  .security-header .container {
    flex-direction: column;
    text-align: center;
  }
  
  .security-indicators {
    justify-content: center;
  }
  
  .action-bar {
    flex-direction: column;
  }
  
  .btn-action {
    width: 100%;
  }
  
  .totp-code {
    font-size: 1.5rem;
  }
  
  .advanced-options {
    grid-template-columns: 1fr;
  }
  
  .form-actions {
    flex-direction: column;
  }
}

@media (max-width: 480px) {
  .app-container {
    padding: 0 10px;
  }
  
  .setup-card,
  .login-card {
    padding: 20px;
    margin: 20px auto;
  }
  
  .totp-code {
    font-size: 1.2rem;
    letter-spacing: 2px;
  }
}
</style>
</head>
<body>
  <!-- Security Status Header -->
  <header class="security-header">
    <div class="container">
      <h1>üîí Personal 2FA</h1>
      <div class="security-indicators">
        <span class="indicator" id="crypto-status">üîê Cifrado: AES-256</span>
        <span class="indicator" id="storage-status">üè† Local</span>
        <span class="indicator" id="network-status">üì° Offline ‚úÖ</span>
      </div>
    </div>
  </header>

  <!-- Main App Container -->
  <main class="app-container">
    
    <!-- First Time Setup -->
    <section id="setup-screen" class="screen active">
      <div class="setup-card">
        <h2>üõ°Ô∏è Configuraci√≥n Inicial de Seguridad</h2>
        <div class="security-notice">
          <h3>Esta aplicaci√≥n es completamente segura:</h3>
          <ul>
            ‚úÖ Funciona 100% offline - Sin conexiones a internet<br>
            ‚úÖ Todos los datos se cifran antes de guardarse<br>
            ‚úÖ Tus c√≥digos nunca salen de tu dispositivo<br>
            ‚úÖ C√≥digo fuente completamente inspecci√≥nable<br>
            ‚úÖ Compatible con Google Authenticator
          </ul>
        </div>
        
        <div class="password-setup">
          <label for="master-password">Crear contrase√±a maestra:</label>
          <input type="password" id="master-password" placeholder="Contrase√±a segura para cifrar tus datos">
          <input type="password" id="confirm-password" placeholder="Confirmar contrase√±a">
          <button id="setup-complete" class="btn-primary">üîí Crear Almac√©n Seguro</button>
        </div>
      </div>
    </section>

    <!-- Login Screen -->
    <section id="login-screen" class="screen">
      <div class="login-card">
        <h2>üîì Desbloquear Personal 2FA</h2>
        <input type="password" id="login-password" placeholder="Contrase√±a maestra">
        <button id="login-btn" class="btn-primary">Desbloquear</button>
        <div id="login-error" class="error-message"></div>
      </div>
    </section>

    <!-- Main App Screen -->
    <section id="main-screen" class="screen">
      
      <!-- Action Buttons -->
      <div class="action-bar">
        <button id="import-btn" class="btn-action">üì• Importar de Google Auth</button>
        <button id="export-btn" class="btn-action">üíæ Exportar Backup</button>
        <button id="add-manual-btn" class="btn-action">‚ûï A√±adir Manual</button>
        <button id="lock-btn" class="btn-secondary">üîí Bloquear</button>
      </div>

      <!-- Import Section -->
      <div id="import-section" class="section hidden">
        <h3>üì± Importar desde Google Authenticator</h3>
        <div class="import-options">
          <div class="qr-scanner">
            <video id="qr-video" autoplay></video>
            <canvas id="qr-canvas" style="display: none;"></canvas>
            <button id="start-camera" class="btn-primary">üìπ Activar C√°mara</button>
            <button id="stop-camera" class="btn-secondary hidden">‚èπÔ∏è Detener</button>
          </div>
          <div class="scan-status">
            <div id="scan-result"></div>
          </div>
        </div>
      </div>

      <!-- Export Section -->
      <div id="export-section" class="section hidden">
        <h3>üíæ Exportar para Backup</h3>
        <p class="export-notice">
          ‚ö†Ô∏è <strong>Importante:</strong> Este export es solo para backup. 
          Los c√≥digos NO se guardar√°n en esta app, solo se generan para que puedas importarlos en otra aplicaci√≥n.
        </p>
        <div class="export-options">
          <button id="export-google-format" class="btn-primary">üì± Formato Google Authenticator</button>
          <button id="export-individual-qr" class="btn-primary">üìÑ QR Individuales</button>
          <button id="export-json-backup" class="btn-primary">üìã Backup JSON</button>
        </div>
        <div id="export-result" class="export-result"></div>
      </div>

      <!-- TOTP Codes Display -->
      <div id="codes-section" class="section">
        <h3>üî¢ C√≥digos de Autenticaci√≥n</h3>
        <div id="totp-list" class="totp-list">
          <!-- Los c√≥digos TOTP se generar√°n aqu√≠ din√°micamente -->
        </div>
        <div id="empty-state" class="empty-state">
          <p>No hay c√≥digos configurados.</p>
          <p>Importa desde Google Authenticator o a√±ade manualmente.</p>
        </div>
      </div>

      <!-- Manual Add Section -->
      <div id="manual-add-section" class="section hidden">
        <h3>‚ûï A√±adir C√≥digo Manualmente</h3>
        <form id="manual-add-form">
          <input type="text" id="manual-issuer" placeholder="Servicio (ej: Google, GitHub)" required>
          <input type="text" id="manual-label" placeholder="Cuenta (ej: user@gmail.com)" required>
          <input type="text" id="manual-secret" placeholder="C√≥digo secreto (Base32)" required>
          <div class="advanced-options">
            <label>
              Algoritmo: 
              <select id="manual-algorithm">
                <option value="SHA1">SHA1 (est√°ndar)</option>
                <option value="SHA256">SHA256</option>
                <option value="SHA512">SHA512</option>
              </select>
            </label>
            <label>
              D√≠gitos: 
              <select id="manual-digits">
                <option value="6">6 (est√°ndar)</option>
                <option value="8">8</option>
              </select>
            </label>
            <label>
              Per√≠odo: 
              <input type="number" id="manual-period" value="30" min="15" max="300">s
            </label>
          </div>
          <div class="form-actions">
            <button type="submit" class="btn-primary">‚úÖ A√±adir C√≥digo</button>
            <button type="button" id="cancel-manual" class="btn-secondary">‚ùå Cancelar</button>
          </div>
        </form>
      </div>

    </section>

  </main>

  <!-- Security verification panel (dev mode) -->
  <div id="security-panel" class="security-panel">
    <h4>üîç Verificaci√≥n de Seguridad</h4>
    <div id="security-checks"></div>
  </div>

  <script>

/* ====================================
   Personal 2FA - Secure Local 2FA App
   Generated: 2025-10-26T08:43:25.847Z
   
   Security Features:
   - AES-256-GCM encryption
   - PBKDF2 key derivation
   - IndexedDB local storage
   - Web Crypto API
   - Offline operation
   ==================================== */


/* ============= crypto.js ============= */
(function() {
  'use strict';
  
/**
 * Secure Cryptography Module
 * Uses Web Crypto API for hardware-accelerated AES-256-GCM encryption
 * All sensitive data is encrypted before storage
 */

class SecureCrypto {
  constructor() {
    this.algorithm = 'AES-GCM';
    this.keyLength = 256;
    this.ivLength = 12; // 96 bits for GCM
    this.tagLength = 128; // 128 bits authentication tag
    this.iterations = 100000; // PBKDF2 iterations
  }

  /**
   * Derive encryption key from password using PBKDF2
   * @param {string} password - Master password
   * @param {Uint8Array} salt - Random salt
   * @returns {Promise<CryptoKey>} Derived key
   */
  async deriveKey(password, salt) {
    const encoder = new TextEncoder();
    const passwordBuffer = encoder.encode(password);
    
    // Import password as base key
    const baseKey = await crypto.subtle.importKey(
      'raw',
      passwordBuffer,
      'PBKDF2',
      false,
      ['deriveKey']
    );
    
    // Derive AES key using PBKDF2
    return await crypto.subtle.deriveKey(
      {
        name: 'PBKDF2',
        salt: salt,
        iterations: this.iterations,
        hash: 'SHA-256'
      },
      baseKey,
      {
        name: this.algorithm,
        length: this.keyLength
      },
      false,
      ['encrypt', 'decrypt']
    );
  }

  /**
   * Generate cryptographically secure random bytes
   * @param {number} length - Number of bytes
   * @returns {Uint8Array} Random bytes
   */
  generateRandomBytes(length) {
    return crypto.getRandomValues(new Uint8Array(length));
  }

  /**
   * Encrypt data using AES-256-GCM
   * @param {string} plaintext - Data to encrypt
   * @param {CryptoKey} key - Encryption key
   * @returns {Promise<Object>} Encrypted data with IV
   */
  async encrypt(plaintext, key) {
    const encoder = new TextEncoder();
    const data = encoder.encode(plaintext);
    
    // Generate random IV for each encryption
    const iv = this.generateRandomBytes(this.ivLength);
    
    // Encrypt data
    const encrypted = await crypto.subtle.encrypt(
      {
        name: this.algorithm,
        iv: iv,
        tagLength: this.tagLength
      },
      key,
      data
    );
    
    return {
      ciphertext: new Uint8Array(encrypted),
      iv: iv
    };
  }

  /**
   * Decrypt data using AES-256-GCM
   * @param {Uint8Array} ciphertext - Encrypted data
   * @param {Uint8Array} iv - Initialization vector
   * @param {CryptoKey} key - Decryption key
   * @returns {Promise<string>} Decrypted plaintext
   */
  async decrypt(ciphertext, iv, key) {
    const decrypted = await crypto.subtle.decrypt(
      {
        name: this.algorithm,
        iv: iv,
        tagLength: this.tagLength
      },
      key,
      ciphertext
    );
    
    const decoder = new TextDecoder();
    return decoder.decode(decrypted);
  }

  /**
   * Hash data using SHA-256
   * @param {string} data - Data to hash
   * @returns {Promise<string>} Hex-encoded hash
   */
  async hash(data) {
    const encoder = new TextEncoder();
    const dataBuffer = encoder.encode(data);
    const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);
    
    // Convert to hex string
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  }

  /**
   * Convert Uint8Array to Base64 string
   * @param {Uint8Array} bytes - Byte array
   * @returns {string} Base64 string
   */
  bytesToBase64(bytes) {
    const binary = String.fromCharCode.apply(null, bytes);
    return btoa(binary);
  }

  /**
   * Convert Base64 string to Uint8Array
   * @param {string} base64 - Base64 string
   * @returns {Uint8Array} Byte array
   */
  base64ToBytes(base64) {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
  }

  /**
   * Securely clear sensitive data from memory
   * @param {string|Uint8Array|Array} sensitiveData - Data to clear
   */
  secureClear(sensitiveData) {
    if (typeof sensitiveData === 'string') {
      // Can't directly clear string in JS, but can overwrite reference
      sensitiveData = null;
    } else if (sensitiveData instanceof Uint8Array || Array.isArray(sensitiveData)) {
      // Overwrite array contents with random data
      crypto.getRandomValues(sensitiveData);
    }
  }

  /**
   * Verify that Web Crypto API is available and secure
   * @returns {Object} Security status
   */
  getSecurityStatus() {
    const status = {
      webCryptoAvailable: !!window.crypto?.subtle,
      secureContext: window.isSecureContext,
      httpsOrLocalhost: window.location.protocol === 'https:' || 
                       window.location.hostname === 'localhost' ||
                       window.location.hostname === '127.0.0.1',
      randomAvailable: !!window.crypto?.getRandomValues
    };
    
    status.isSecure = status.webCryptoAvailable && 
                     status.secureContext && 
                     status.randomAvailable;
    
    return status;
  }
}

// Export singleton instance
const cryptoManager = new SecureCrypto();
  // Export to global scope
  window.SecureCrypto = SecureCrypto;
  window.cryptoManager = cryptoManager;

})();


/* ============= storage.js ============= */
(function() {
  'use strict';
  
/**
 * Secure Local Storage Module
 * Uses IndexedDB for persistent encrypted storage
 * All TOTP secrets and configuration are encrypted before storage
 */

class SecureStorage {
  constructor() {
    this.dbName = 'Personal2FA';
    this.dbVersion = 1;
    this.storeName = 'secrets';
    this.configStore = 'config';
    this.db = null;
    this.isInitialized = false;
    this.encryptionKey = null;
  }

  /**
   * Initialize IndexedDB database
   * @returns {Promise<void>}
   */
  async init() {
    if (this.isInitialized) return;
    
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.dbVersion);
      
      request.onerror = () => reject(new Error('Failed to open IndexedDB'));
      
      request.onsuccess = (event) => {
        this.db = event.target.result;
        this.isInitialized = true;
        resolve();
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        // Create secrets store for encrypted TOTP data
        if (!db.objectStoreNames.contains(this.storeName)) {
          const secretsStore = db.createObjectStore(this.storeName, {
            keyPath: 'id',
            autoIncrement: true
          });
          secretsStore.createIndex('issuer', 'issuer', { unique: false });
          secretsStore.createIndex('label', 'label', { unique: false });
        }
        
        // Create config store for app configuration
        if (!db.objectStoreNames.contains(this.configStore)) {
          db.createObjectStore(this.configStore, { keyPath: 'key' });
        }
      };
    });
  }

  /**
   * Setup master password and derive encryption key
   * @param {string} password - Master password
   * @returns {Promise<void>}
   */
  async setupMasterPassword(password) {
    // Generate random salt for this installation
    const salt = cryptoManager.generateRandomBytes(32);
    
    // Store salt (unencrypted, needed for key derivation)
    await this.setConfig('salt', cryptoManager.bytesToBase64(salt));
    
    // Derive encryption key from password
    this.encryptionKey = await cryptoManager.deriveKey(password, salt);
    
    // Store password verification hash
    const passwordHash = await cryptoManager.hash(password);
    await this.setConfig('passwordHash', passwordHash);
    
    // Mark as setup complete
    await this.setConfig('isSetup', true);
  }

  /**
   * Unlock storage with master password
   * @param {string} password - Master password
   * @returns {Promise<boolean>} True if password is correct
   */
  async unlock(password) {
    const storedHash = await this.getConfig('passwordHash');
    const passwordHash = await cryptoManager.hash(password);
    
    if (storedHash !== passwordHash) {
      return false;
    }
    
    // Derive encryption key
    const saltBase64 = await this.getConfig('salt');
    const salt = cryptoManager.base64ToBytes(saltBase64);
    this.encryptionKey = await cryptoManager.deriveKey(password, salt);
    
    return true;
  }

  /**
   * Check if storage is already setup
   * @returns {Promise<boolean>}
   */
  async isSetup() {
    const setup = await this.getConfig('isSetup');
    return setup === true;
  }

  /**
   * Lock storage (clear encryption key from memory)
   */
  lock() {
    this.encryptionKey = null;
  }

  /**
   * Check if storage is currently unlocked
   * @returns {boolean}
   */
  isUnlocked() {
    return this.encryptionKey !== null;
  }

  /**
   * Store encrypted TOTP secret
   * @param {Object} totpData - TOTP configuration
   * @returns {Promise<number>} Generated ID
   */
  async storeTOTPSecret(totpData) {
    if (!this.isUnlocked()) {
      throw new Error('Storage is locked. Unlock with master password first.');
    }
    
    // Encrypt the sensitive secret
    const secretJson = JSON.stringify({
      secret: totpData.secret,
      algorithm: totpData.algorithm || 'SHA1',
      digits: totpData.digits || 6,
      period: totpData.period || 30
    });
    
    const encrypted = await cryptoManager.encrypt(secretJson, this.encryptionKey);
    
    // Store encrypted data with unencrypted metadata
    const record = {
      issuer: totpData.issuer,
      label: totpData.label,
      encryptedSecret: cryptoManager.bytesToBase64(encrypted.ciphertext),
      iv: cryptoManager.bytesToBase64(encrypted.iv),
      createdAt: new Date().toISOString(),
      lastUsed: null
    };
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const request = store.add(record);
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(new Error('Failed to store TOTP secret'));
    });
  }

  /**
   * Retrieve all TOTP secrets (decrypted)
   * @returns {Promise<Array>} Array of TOTP configurations
   */
  async getAllTOTPSecrets() {
    if (!this.isUnlocked()) {
      throw new Error('Storage is locked. Unlock with master password first.');
    }
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readonly');
      const store = transaction.objectStore(this.storeName);
      const request = store.getAll();
      
      request.onsuccess = async () => {
        const records = request.result;
        const decryptedSecrets = [];
        
        for (const record of records) {
          try {
            // Decrypt the secret
            const ciphertext = cryptoManager.base64ToBytes(record.encryptedSecret);
            const iv = cryptoManager.base64ToBytes(record.iv);
            const decryptedJson = await cryptoManager.decrypt(ciphertext, iv, this.encryptionKey);
            const secretData = JSON.parse(decryptedJson);
            
            decryptedSecrets.push({
              id: record.id,
              issuer: record.issuer,
              label: record.label,
              secret: secretData.secret,
              algorithm: secretData.algorithm,
              digits: secretData.digits,
              period: secretData.period,
              createdAt: record.createdAt,
              lastUsed: record.lastUsed
            });
          } catch (error) {
            console.error('Failed to decrypt TOTP secret:', error);
            // Skip corrupted records
          }
        }
        
        resolve(decryptedSecrets);
      };
      
      request.onerror = () => reject(new Error('Failed to retrieve TOTP secrets'));
    });
  }

  /**
   * Delete TOTP secret by ID
   * @param {number} id - Secret ID
   * @returns {Promise<void>}
   */
  async deleteTOTPSecret(id) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const request = store.delete(id);
      
      request.onsuccess = () => resolve();
      request.onerror = () => reject(new Error('Failed to delete TOTP secret'));
    });
  }

  /**
   * Update last used timestamp for TOTP secret
   * @param {number} id - Secret ID
   * @returns {Promise<void>}
   */
  async updateLastUsed(id) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const getRequest = store.get(id);
      
      getRequest.onsuccess = () => {
        const record = getRequest.result;
        if (record) {
          record.lastUsed = new Date().toISOString();
          const putRequest = store.put(record);
          putRequest.onsuccess = () => resolve();
          putRequest.onerror = () => reject(new Error('Failed to update last used'));
        } else {
          reject(new Error('TOTP secret not found'));
        }
      };
      
      getRequest.onerror = () => reject(new Error('Failed to find TOTP secret'));
    });
  }

  /**
   * Store configuration value
   * @param {string} key - Config key
   * @param {any} value - Config value
   * @returns {Promise<void>}
   */
  async setConfig(key, value) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.configStore], 'readwrite');
      const store = transaction.objectStore(this.configStore);
      const request = store.put({ key, value });
      
      request.onsuccess = () => resolve();
      request.onerror = () => reject(new Error(`Failed to store config: ${key}`));
    });
  }

  /**
   * Get configuration value
   * @param {string} key - Config key
   * @returns {Promise<any>} Config value
   */
  async getConfig(key) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.configStore], 'readonly');
      const store = transaction.objectStore(this.configStore);
      const request = store.get(key);
      
      request.onsuccess = () => {
        const result = request.result;
        resolve(result ? result.value : null);
      };
      
      request.onerror = () => reject(new Error(`Failed to get config: ${key}`));
    });
  }

  /**
   * Clear all data (factory reset)
   * @returns {Promise<void>}
   */
  async clearAllData() {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName, this.configStore], 'readwrite');
      
      const secretsStore = transaction.objectStore(this.storeName);
      const configStore = transaction.objectStore(this.configStore);
      
      const clearSecrets = secretsStore.clear();
      const clearConfig = configStore.clear();
      
      let completed = 0;
      const complete = () => {
        completed++;
        if (completed === 2) {
          this.encryptionKey = null;
          resolve();
        }
      };
      
      clearSecrets.onsuccess = complete;
      clearConfig.onsuccess = complete;
      
      clearSecrets.onerror = clearConfig.onerror = () => {
        reject(new Error('Failed to clear data'));
      };
    });
  }

  /**
   * Get storage statistics
   * @returns {Promise<Object>} Storage stats
   */
  async getStats() {
    const secretCount = await new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readonly');
      const store = transaction.objectStore(this.storeName);
      const request = store.count();
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(new Error('Failed to count secrets'));
    });
    
    return {
      totalSecrets: secretCount,
      isSetup: await this.isSetup(),
      isUnlocked: this.isUnlocked(),
      dbSize: await this.estimateDbSize()
    };
  }

  /**
   * Estimate database size (approximate)
   * @returns {Promise<number>} Estimated size in bytes
   */
  async estimateDbSize() {
    if ('estimate' in navigator.storage) {
      const estimate = await navigator.storage.estimate();
      return estimate.usage || 0;
    }
    return 0; // Cannot estimate
  }
}

// Export singleton instance
const storageManager = new SecureStorage();
  // Export to global scope
  window.SecureStorage = SecureStorage;
  window.storageManager = storageManager;

})();


/* ============= totp.js ============= */
(function() {
  'use strict';
  
/**
 * TOTP (Time-based One-Time Password) Generator
 * Implements RFC 6238 TOTP algorithm
 * Supports SHA1, SHA256, SHA512 algorithms
 */

class TOTPGenerator {
  constructor() {
    this.defaultAlgorithm = 'SHA1';
    this.defaultDigits = 6;
    this.defaultPeriod = 30;
  }

  /**
   * Generate TOTP code from secret
   * @param {string} secret - Base32 encoded secret
   * @param {Object} options - TOTP configuration
   * @returns {Promise<Object>} TOTP code and timing info
   */
  async generateTOTP(secret, options = {}) {
    const {
      algorithm = this.defaultAlgorithm,
      digits = this.defaultDigits,
      period = this.defaultPeriod,
      timestamp = Date.now()
    } = options;

    // Calculate time counter
    const timeCounter = Math.floor(timestamp / 1000 / period);
    
    // Generate HOTP
    const code = await this.generateHOTP(secret, timeCounter, { algorithm, digits });
    
    // Calculate timing information
    const currentPeriodStart = timeCounter * period * 1000;
    const nextPeriodStart = currentPeriodStart + (period * 1000);
    const timeRemaining = Math.ceil((nextPeriodStart - timestamp) / 1000);
    const progress = ((timestamp - currentPeriodStart) / (period * 1000)) * 100;
    
    return {
      code,
      timeRemaining,
      progress,
      period,
      algorithm,
      digits
    };
  }

  /**
   * Generate HOTP code (RFC 4226)
   * @param {string} secret - Base32 encoded secret
   * @param {number} counter - Counter value
   * @param {Object} options - HOTP configuration
   * @returns {Promise<string>} HOTP code
   */
  async generateHOTP(secret, counter, options = {}) {
    const {
      algorithm = this.defaultAlgorithm,
      digits = this.defaultDigits
    } = options;

    // Decode Base32 secret to bytes
    const secretBytes = this.base32Decode(secret);
    
    // Convert counter to 8-byte big-endian format
    const counterBytes = new ArrayBuffer(8);
    const counterView = new DataView(counterBytes);
    counterView.setUint32(4, counter, false); // Big-endian
    
    // Import secret key for HMAC
    const key = await crypto.subtle.importKey(
      'raw',
      secretBytes,
      { name: 'HMAC', hash: `SHA-${this.getHashSize(algorithm)}` },
      false,
      ['sign']
    );
    
    // Generate HMAC
    const signature = await crypto.subtle.sign('HMAC', key, counterBytes);
    const hmac = new Uint8Array(signature);
    
    // Dynamic truncation (RFC 4226 Section 5.4)
    const offset = hmac[hmac.length - 1] & 0x0f;
    const truncated = (
      ((hmac[offset] & 0x7f) << 24) |
      ((hmac[offset + 1] & 0xff) << 16) |
      ((hmac[offset + 2] & 0xff) << 8) |
      (hmac[offset + 3] & 0xff)
    ) >>> 0; // Unsigned 32-bit
    
    // Generate final code
    const code = (truncated % Math.pow(10, digits)).toString().padStart(digits, '0');
    
    return code;
  }

  /**
   * Validate TOTP code
   * @param {string} code - Code to validate
   * @param {string} secret - Base32 encoded secret
   * @param {Object} options - Validation options
   * @returns {Promise<boolean>} True if code is valid
   */
  async validateTOTP(code, secret, options = {}) {
    const {
      algorithm = this.defaultAlgorithm,
      digits = this.defaultDigits,
      period = this.defaultPeriod,
      window = 1, // Allow 1 period before/after current
      timestamp = Date.now()
    } = options;

    const currentCounter = Math.floor(timestamp / 1000 / period);
    
    // Check current period and adjacent periods (for clock drift)
    for (let i = -window; i <= window; i++) {
      const testCounter = currentCounter + i;
      const testCode = await this.generateHOTP(secret, testCounter, { algorithm, digits });
      
      if (code === testCode) {
        return true;
      }
    }
    
    return false;
  }

  /**
   * Parse otpauth:// URI
   * @param {string} uri - otpauth:// URI
   * @returns {Object} Parsed TOTP configuration
   */
  parseOTPAuthURI(uri) {
    try {
      const url = new URL(uri);
      
      if (url.protocol !== 'otpauth:') {
        throw new Error('Invalid protocol. Expected otpauth://');
      }
      
      const type = url.hostname.toLowerCase();
      if (type !== 'totp' && type !== 'hotp') {
        throw new Error('Unsupported OTP type. Expected totp or hotp');
      }
      
      // Parse label (issuer:account or just account)
      const label = decodeURIComponent(url.pathname.substring(1));
      let issuer = '';
      let account = label;
      
      const colonIndex = label.indexOf(':');
      if (colonIndex !== -1) {
        issuer = label.substring(0, colonIndex);
        account = label.substring(colonIndex + 1);
      }
      
      // Parse query parameters
      const params = new URLSearchParams(url.search);
      const secret = params.get('secret');
      const issuerParam = params.get('issuer');
      const algorithm = params.get('algorithm') || 'SHA1';
      const digits = parseInt(params.get('digits')) || 6;
      const period = parseInt(params.get('period')) || 30;
      const counter = params.get('counter');
      
      if (!secret) {
        throw new Error('Secret parameter is required');
      }
      
      // Validate Base32 secret
      if (!this.isValidBase32(secret)) {
        throw new Error('Invalid Base32 secret');
      }
      
      return {
        type,
        issuer: issuerParam || issuer,
        label: account,
        secret: secret.toUpperCase().replace(/\s/g, ''), // Normalize
        algorithm: algorithm.toUpperCase(),
        digits,
        period: type === 'totp' ? period : undefined,
        counter: type === 'hotp' ? parseInt(counter) || 0 : undefined
      };
    } catch (error) {
      throw new Error(`Invalid otpauth URI: ${error.message}`);
    }
  }

  /**
   * Generate otpauth:// URI
   * @param {Object} config - TOTP configuration
   * @returns {string} otpauth:// URI
   */
  generateOTPAuthURI(config) {
    const {
      issuer,
      label,
      secret,
      algorithm = 'SHA1',
      digits = 6,
      period = 30,
      type = 'totp'
    } = config;
    
    if (!secret || !label) {
      throw new Error('Secret and label are required');
    }
    
    // Construct label with issuer
    const fullLabel = issuer ? `${issuer}:${label}` : label;
    
    // Build URI
    const uri = new URL(`otpauth://${type}/${encodeURIComponent(fullLabel)}`);
    
    uri.searchParams.set('secret', secret.toUpperCase().replace(/\s/g, ''));
    
    if (issuer) {
      uri.searchParams.set('issuer', issuer);
    }
    
    if (algorithm !== 'SHA1') {
      uri.searchParams.set('algorithm', algorithm);
    }
    
    if (digits !== 6) {
      uri.searchParams.set('digits', digits.toString());
    }
    
    if (type === 'totp' && period !== 30) {
      uri.searchParams.set('period', period.toString());
    }
    
    return uri.toString();
  }

  /**
   * Decode Base32 string to bytes
   * @param {string} base32 - Base32 encoded string
   * @returns {Uint8Array} Decoded bytes
   */
  base32Decode(base32) {
    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
    const cleanInput = base32.toUpperCase().replace(/[^A-Z2-7]/g, '');
    
    let bits = '';
    for (const char of cleanInput) {
      const index = alphabet.indexOf(char);
      if (index === -1) {
        throw new Error(`Invalid Base32 character: ${char}`);
      }
      bits += index.toString(2).padStart(5, '0');
    }
    
    // Convert bits to bytes
    const bytes = [];
    for (let i = 0; i < bits.length - 4; i += 8) {
      const byte = bits.substring(i, i + 8);
      if (byte.length === 8) {
        bytes.push(parseInt(byte, 2));
      }
    }
    
    return new Uint8Array(bytes);
  }

  /**
   * Encode bytes to Base32 string
   * @param {Uint8Array} bytes - Bytes to encode
   * @returns {string} Base32 encoded string
   */
  base32Encode(bytes) {
    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
    let bits = '';
    
    // Convert bytes to bits
    for (const byte of bytes) {
      bits += byte.toString(2).padStart(8, '0');
    }
    
    // Pad to multiple of 5 bits
    while (bits.length % 5 !== 0) {
      bits += '0';
    }
    
    // Convert to Base32
    let result = '';
    for (let i = 0; i < bits.length; i += 5) {
      const chunk = bits.substring(i, i + 5);
      result += alphabet[parseInt(chunk, 2)];
    }
    
    return result;
  }

  /**
   * Validate Base32 string
   * @param {string} base32 - Base32 string to validate
   * @returns {boolean} True if valid Base32
   */
  isValidBase32(base32) {
    const cleanInput = base32.toUpperCase().replace(/\s/g, '');
    return /^[A-Z2-7]*$/.test(cleanInput);
  }

  /**
   * Get hash size for algorithm
   * @param {string} algorithm - Hash algorithm
   * @returns {number} Hash size
   */
  getHashSize(algorithm) {
    switch (algorithm.toUpperCase()) {
      case 'SHA1': return 1;
      case 'SHA256': return 256;
      case 'SHA512': return 512;
      default: throw new Error(`Unsupported algorithm: ${algorithm}`);
    }
  }

  /**
   * Generate random Base32 secret
   * @param {number} length - Length in bytes (default: 20 for 160-bit)
   * @returns {string} Base32 encoded secret
   */
  generateSecret(length = 20) {
    const bytes = crypto.getRandomValues(new Uint8Array(length));
    return this.base32Encode(bytes);
  }
}

// Export singleton instance
const totpGenerator = new TOTPGenerator();
  // Export to global scope
  window.TOTPGenerator = TOTPGenerator;
  window.totpGenerator = totpGenerator;

})();


/* ============= qr.js ============= */
(function() {
  'use strict';
  
/**
 * QR Code Scanner and Generator Module
 * Handles QR code scanning via camera and generation for export
 * Supports Google Authenticator migration format
 */

// Import QR generation library
class QRManager {
  constructor() {
    this.video = null;
    this.canvas = null;
    this.context = null;
    this.scanning = false;
    this.onQRDetected = null;
    this.scanInterval = null;
  }

  /**
   * Initialize QR scanner with video element
   * @param {HTMLVideoElement} videoElement - Video element for camera stream
   * @param {HTMLCanvasElement} canvasElement - Canvas for image processing
   */
  init(videoElement, canvasElement) {
    this.video = videoElement;
    this.canvas = canvasElement;
    this.context = canvasElement.getContext('2d');
  }

  /**
   * Start camera and begin QR code scanning
   * @param {Function} onDetected - Callback function when QR is detected
   * @returns {Promise<void>}
   */
  async startScanning(onDetected) {
    try {
      this.onQRDetected = onDetected;
      
      // Request camera access
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          width: { ideal: 640 },
          height: { ideal: 480 },
          facingMode: 'environment' // Use back camera on mobile
        }
      });
      
      this.video.srcObject = stream;
      this.video.play();
      
      // Wait for video to be ready
      await new Promise((resolve) => {
        this.video.onloadedmetadata = () => {
          // Set canvas size to match video
          this.canvas.width = this.video.videoWidth;
          this.canvas.height = this.video.videoHeight;
          resolve();
        };
      });
      
      this.scanning = true;
      this.startQRDetection();
      
    } catch (error) {
      throw new Error(`Failed to start camera: ${error.message}`);
    }
  }

  /**
   * Stop camera and QR scanning
   */
  stopScanning() {
    this.scanning = false;
    
    if (this.scanInterval) {
      clearInterval(this.scanInterval);
      this.scanInterval = null;
    }
    
    if (this.video && this.video.srcObject) {
      const tracks = this.video.srcObject.getTracks();
      tracks.forEach(track => track.stop());
      this.video.srcObject = null;
    }
  }

  /**
   * Start continuous QR detection from video stream
   */
  startQRDetection() {
    this.scanInterval = setInterval(() => {
      if (!this.scanning || !this.video || this.video.readyState !== 4) {
        return;
      }
      
      // Capture frame from video
      this.context.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
      
      // Get image data for QR detection
      const imageData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
      
      try {
        const qrData = this.detectQRCode(imageData);
        if (qrData && this.onQRDetected) {
          this.onQRDetected(qrData);
        }
      } catch (error) {
        // QR detection failed, continue scanning
      }
    }, 250); // Scan every 250ms
  }

  /**
   * Detect QR code in image data (basic implementation)
   * In a real implementation, you would use a library like jsQR or zxing
   * @param {ImageData} imageData - Image data from canvas
   * @returns {string|null} QR code data or null if not found
   */
  detectQRCode(imageData) {
    // This is a placeholder implementation
    // In production, use a proper QR detection library like:
    // - jsQR: https://github.com/cozmo/jsQR
    // - @zxing/library: https://github.com/zxing-js/library
    
    // For now, we'll use a simple pattern matching approach
    // This would be replaced with actual QR detection
    return this.mockQRDetection();
  }

  /**
   * Mock QR detection for development
   * Replace this with actual QR detection library
   * @returns {string|null} Mock QR data
   */
  mockQRDetection() {
    // Simulate QR detection with random chance
    if (Math.random() < 0.01) { // 1% chance per scan
      // Create a realistic mock migration payload
      const mockSecret = {
        secret: 'JBSWY3DPEHPK3PXP',
        name: 'test@example.com',
        issuer: 'Google',
        algorithm: 1, // SHA1
        digits: 6,
        type: 2 // TOTP
      };
      
      // Create a simple protobuf-like structure
      const secretBytes = this.base32ToBytes(mockSecret.secret);
      const nameBytes = new TextEncoder().encode(mockSecret.name);
      const issuerBytes = new TextEncoder().encode(mockSecret.issuer);
      
      // Simple protobuf encoding (field 1)
      let payload = new Uint8Array([
        0x0A, // Field 1, wire type 2 (length-delimited)
        30 + secretBytes.length + nameBytes.length + issuerBytes.length, // Length
        
        // Secret (field 1)
        0x0A, secretBytes.length, ...secretBytes,
        
        // Name (field 2) 
        0x12, nameBytes.length, ...nameBytes,
        
        // Issuer (field 3)
        0x1A, issuerBytes.length, ...issuerBytes,
        
        // Algorithm (field 4)
        0x20, mockSecret.algorithm,
        
        // Digits (field 5)
        0x28, mockSecret.digits,
        
        // Type (field 6)
        0x30, mockSecret.type
      ]);
      
      // Convert to string for base64 encoding
      const payloadString = String.fromCharCode.apply(null, payload);
      const base64Data = btoa(payloadString);
      
      return `otpauth-migration://offline?data=${base64Data}`;
    }
    return null;
  }

  /**
   * Convert Base32 to bytes (helper for mock)
   * @param {string} base32 - Base32 string
   * @returns {Uint8Array} Decoded bytes
   */
  base32ToBytes(base32) {
    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
    let bits = '';
    
    for (const char of base32.toUpperCase()) {
      const index = alphabet.indexOf(char);
      if (index !== -1) {
        bits += index.toString(2).padStart(5, '0');
      }
    }
    
    const bytes = [];
    for (let i = 0; i < bits.length - 4; i += 8) {
      const byte = bits.substring(i, i + 8);
      if (byte.length === 8) {
        bytes.push(parseInt(byte, 2));
      }
    }
    
    return new Uint8Array(bytes);
  }

  /**
   * Generate QR code for otpauth:// URI
   * @param {string} otpauthUri - otpauth:// URI
   * @param {Object} options - QR generation options
   * @returns {Promise<string>} Data URL of QR code image
   */
  async generateQRCode(otpauthUri, options = {}) {
    const {
      errorCorrectionLevel = 'M',
      type = 'image/png',
      quality = 0.92,
      margin = 1,
      color = {
        dark: '#000000',
        light: '#FFFFFF'
      },
      width = 256
    } = options;

    try {
      const qrDataUrl = await QRCode.toDataURL(otpauthUri, {
        errorCorrectionLevel,
        type,
        quality,
        margin,
        color,
        width
      });
      
      return qrDataUrl;
    } catch (error) {
      throw new Error(`Failed to generate QR code: ${error.message}`);
    }
  }

  /**
   * Generate QR code for Google Authenticator migration
   * @param {Array} totpSecrets - Array of TOTP configurations
   * @returns {Promise<string>} Data URL of migration QR code
   */
  async generateMigrationQR(totpSecrets) {
    try {
      // Create migration payload (simplified version)
      const migrationData = this.createMigrationPayload(totpSecrets);
      
      // Encode to Base64
      const base64Data = btoa(migrationData);
      
      // Create migration URI
      const migrationUri = `otpauth-migration://offline?data=${base64Data}`;
      
      // Generate QR code
      return await this.generateQRCode(migrationUri, {
        errorCorrectionLevel: 'L', // Lower correction for larger data
        width: 400 // Larger size for migration QR
      });
    } catch (error) {
      throw new Error(`Failed to generate migration QR: ${error.message}`);
    }
  }

  /**
   * Create Google Authenticator migration payload
   * @param {Array} totpSecrets - Array of TOTP configurations
   * @returns {string} Binary migration data
   */
  createMigrationPayload(totpSecrets) {
    // This is a simplified version of Google's migration format
    // In production, you would use protobuf.js to properly encode the data
    
    let payload = '';
    
    for (const secret of totpSecrets) {
      // Simplified payload structure (not actual protobuf)
      const secretData = {
        secret: secret.secret,
        name: secret.label,
        issuer: secret.issuer,
        algorithm: this.algorithmToNumber(secret.algorithm),
        digits: secret.digits,
        type: 2, // TOTP
        counter: 0
      };
      
      // This would be properly encoded with protobuf in production
      payload += JSON.stringify(secretData) + '\n';
    }
    
    return payload;
  }

  /**
   * Parse Google Authenticator migration QR data
   * @param {string} migrationUri - Migration URI from QR code
   * @returns {Array} Array of TOTP configurations
   */
  parseMigrationQR(migrationUri) {
    try {
      const url = new URL(migrationUri);
      
      if (url.protocol !== 'otpauth-migration:') {
        throw new Error('Invalid migration URI protocol');
      }
      
      const dataParam = url.searchParams.get('data');
      if (!dataParam) {
        throw new Error('Missing data parameter in migration URI');
      }
      
      // Decode Base64 data
      const decodedData = atob(dataParam);
      
      // Parse migration data (simplified - would use protobuf in production)
      return this.parseMigrationData(decodedData);
    } catch (error) {
      throw new Error(`Failed to parse migration QR: ${error.message}`);
    }
  }

  /**
   * Parse migration data payload
   * @param {string} data - Decoded migration data
   * @returns {Array} Array of TOTP configurations
   */
  parseMigrationData(data) {
    try {
      // Simple protobuf-like parsing for Google Authenticator format
      // This is a basic implementation that handles the most common case
      
      const secrets = [];
      const bytes = new Uint8Array([...data].map(char => char.charCodeAt(0)));
      
      // Basic protobuf parsing - looking for field patterns
      let i = 0;
      while (i < bytes.length) {
        // Look for protobuf field markers
        if (bytes[i] === 0x0A) { // Field 1 (OtpParameters)
          i++; // Skip field tag
          const length = bytes[i++]; // Get length
          
          if (length && i + length <= bytes.length) {
            const secretData = this.parseOtpParameters(bytes.slice(i, i + length));
            if (secretData && secretData.secret && secretData.label) {
              secrets.push(secretData);
            }
            i += length;
          } else {
            break;
          }
        } else {
          i++;
        }
      }
      
      // If protobuf parsing fails, try fallback parsing
      if (secrets.length === 0) {
        return this.parseMigrationDataFallback(data);
      }
      
      return secrets;
    } catch (error) {
      console.warn('Migration parsing failed, trying fallback:', error);
      return this.parseMigrationDataFallback(data);
    }
  }

  /**
   * Parse OTP parameters from protobuf data
   * @param {Uint8Array} data - OTP parameters data
   * @returns {Object|null} Parsed TOTP configuration
   */
  parseOtpParameters(data) {
    try {
      const params = {
        secret: '',
        label: '',
        issuer: '',
        algorithm: 'SHA1',
        digits: 6,
        period: 30
      };
      
      let i = 0;
      while (i < data.length) {
        const tag = data[i++];
        const field = tag >> 3;
        const wireType = tag & 0x07;
        
        switch (field) {
          case 1: // secret
            if (wireType === 2) { // Length-delimited
              const length = data[i++];
              if (i + length <= data.length) {
                // Convert bytes to Base32
                const secretBytes = data.slice(i, i + length);
                params.secret = this.bytesToBase32(secretBytes);
                i += length;
              }
            }
            break;
          case 2: // name/label
            if (wireType === 2) {
              const length = data[i++];
              if (i + length <= data.length) {
                params.label = new TextDecoder().decode(data.slice(i, i + length));
                i += length;
              }
            }
            break;
          case 3: // issuer
            if (wireType === 2) {
              const length = data[i++];
              if (i + length <= data.length) {
                params.issuer = new TextDecoder().decode(data.slice(i, i + length));
                i += length;
              }
            }
            break;
          case 4: // algorithm
            if (wireType === 0) { // Varint
              const algorithm = data[i++];
              params.algorithm = this.numberToAlgorithm(algorithm);
            }
            break;
          case 5: // digits
            if (wireType === 0) {
              params.digits = data[i++];
            }
            break;
          default:
            // Skip unknown fields
            if (wireType === 0) {
              i++; // Skip varint
            } else if (wireType === 2) {
              const length = data[i++];
              i += length; // Skip length-delimited
            } else {
              i++; // Skip other types
            }
        }
      }
      
      return params.secret && params.label ? params : null;
    } catch (error) {
      return null;
    }
  }

  /**
   * Fallback parser for migration data
   * @param {string} data - Migration data
   * @returns {Array} Array of TOTP configurations
   */
  parseMigrationDataFallback(data) {
    // Extract readable strings from the binary data
    const strings = data.match(/[a-zA-Z0-9@._-]{3,}/g) || [];
    
    // Try to identify patterns
    const secrets = [];
    let currentSecret = null;
    
    for (const str of strings) {
      // Check if it looks like a Base32 secret (only uppercase letters and digits 2-7)
      if (/^[A-Z2-7]{16,}$/.test(str) && str.length >= 16) {
        if (currentSecret) {
          secrets.push(currentSecret);
        }
        currentSecret = {
          secret: str,
          label: '',
          issuer: '',
          algorithm: 'SHA1',
          digits: 6,
          period: 30
        };
      }
      // Check if it looks like an email or account name
      else if (str.includes('@') || str.includes('.')) {
        if (currentSecret && !currentSecret.label) {
          currentSecret.label = str;
        }
      }
      // Check if it looks like a service name
      else if (str.length > 2 && str.length < 20 && /^[A-Za-z]/.test(str)) {
        if (currentSecret && !currentSecret.issuer) {
          currentSecret.issuer = str;
        }
      }
    }
    
    if (currentSecret) {
      secrets.push(currentSecret);
    }
    
    return secrets.filter(s => s.secret && (s.label || s.issuer));
  }

  /**
   * Convert bytes to Base32 (for secret encoding)
   * @param {Uint8Array} bytes - Bytes to encode
   * @returns {string} Base32 string
   */
  bytesToBase32(bytes) {
    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
    let bits = '';
    
    // Convert bytes to bits
    for (const byte of bytes) {
      bits += byte.toString(2).padStart(8, '0');
    }
    
    // Pad to multiple of 5 bits
    while (bits.length % 5 !== 0) {
      bits += '0';
    }
    
    // Convert to Base32
    let result = '';
    for (let i = 0; i < bits.length; i += 5) {
      const chunk = bits.substring(i, i + 5);
      result += alphabet[parseInt(chunk, 2)];
    }
    
    return result;
  }

  /**
   * Convert algorithm name to number (Google's format)
   * @param {string} algorithm - Algorithm name
   * @returns {number} Algorithm number
   */
  algorithmToNumber(algorithm) {
    switch (algorithm?.toUpperCase()) {
      case 'SHA1': return 1;
      case 'SHA256': return 2;
      case 'SHA512': return 3;
      default: return 1; // Default to SHA1
    }
  }

  /**
   * Convert algorithm number to name (Google's format)
   * @param {number} algorithmNumber - Algorithm number
   * @returns {string} Algorithm name
   */
  numberToAlgorithm(algorithmNumber) {
    switch (algorithmNumber) {
      case 1: return 'SHA1';
      case 2: return 'SHA256';
      case 3: return 'SHA512';
      default: return 'SHA1';
    }
  }

  /**
   * Check if camera is available
   * @returns {Promise<boolean>} True if camera is available
   */
  async isCameraAvailable() {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      return devices.some(device => device.kind === 'videoinput');
    } catch (error) {
      return false;
    }
  }

  /**
   * Check camera permissions
   * @returns {Promise<string>} Permission state
   */
  async checkCameraPermission() {
    try {
      const permission = await navigator.permissions.query({ name: 'camera' });
      return permission.state; // 'granted', 'denied', 'prompt'
    } catch (error) {
      return 'unknown';
    }
  }
}

// Export singleton instance
const qrManager = new QRManager();
  // Export to global scope
  window.QRManager = QRManager;
  window.qrManager = qrManager;

})();


/* ============= googleAuth.js ============= */
(function() {
  'use strict';
  
/**
 * Google Authenticator Import/Export Module
 * Handles bidirectional sync with Google Authenticator
 * Import: Parse migration QR codes from Google Auth
 * Export: Generate QR codes for backup (NOT for storing in this app)
 */

class GoogleAuthManager {
  constructor() {
    this.exportedSecrets = []; // Temporary storage for export-only mode
  }

  /**
   * Import TOTP secrets from Google Authenticator migration QR
   * @param {string} migrationUri - Migration URI from QR scan
   * @returns {Promise<Array>} Array of imported TOTP configurations
   */
  async importFromGoogleAuth(migrationUri) {
    try {
      console.log('üîÑ Importing from Google Authenticator...');
      
      // Parse the migration QR data
      const secrets = qrManager.parseMigrationQR(migrationUri);
      
      if (!secrets || secrets.length === 0) {
        throw new Error('No TOTP secrets found in migration data');
      }
      
      console.log(`‚úÖ Found ${secrets.length} TOTP secrets to import`);
      
      // Validate and normalize each secret
      const validatedSecrets = [];
      for (const secret of secrets) {
        try {
          const validated = await this.validateTOTPSecret(secret);
          validatedSecrets.push(validated);
        } catch (error) {
          console.warn(`‚ö†Ô∏è Skipping invalid secret for ${secret.issuer}:${secret.label}:`, error.message);
        }
      }
      
      return validatedSecrets;
    } catch (error) {
      throw new Error(`Import failed: ${error.message}`);
    }
  }

  /**
   * Generate export QRs for backup (NOT for storing in app)
   * This creates QR codes that can be imported into other authenticator apps
   * @param {Array} secrets - TOTP secrets to export
   * @param {string} format - Export format ('individual' | 'migration')
   * @returns {Promise<Array>} Array of QR code data URLs
   */
  async generateExportQRs(secrets, format = 'individual') {
    try {
      console.log(`üì§ Generating ${format} export QRs for ${secrets.length} secrets...`);
      
      if (format === 'individual') {
        return await this.generateIndividualQRs(secrets);
      } else if (format === 'migration') {
        return await this.generateMigrationQRs(secrets);
      } else {
        throw new Error(`Unsupported export format: ${format}`);
      }
    } catch (error) {
      throw new Error(`Export failed: ${error.message}`);
    }
  }

  /**
   * Generate individual QR codes (one per TOTP secret)
   * @param {Array} secrets - TOTP secrets
   * @returns {Promise<Array>} Array of QR data objects
   */
  async generateIndividualQRs(secrets) {
    const qrCodes = [];
    
    for (const secret of secrets) {
      try {
        // Generate otpauth:// URI
        const otpauthUri = totpGenerator.generateOTPAuthURI({
          type: 'totp',
          issuer: secret.issuer,
          label: secret.label,
          secret: secret.secret,
          algorithm: secret.algorithm,
          digits: secret.digits,
          period: secret.period
        });
        
        // Generate QR code
        const qrDataUrl = await qrManager.generateQRCode(otpauthUri);
        
        qrCodes.push({
          type: 'individual',
          issuer: secret.issuer,
          label: secret.label,
          qrCode: qrDataUrl,
          otpauthUri: otpauthUri
        });
        
        console.log(`‚úÖ Generated QR for ${secret.issuer}:${secret.label}`);
      } catch (error) {
        console.error(`‚ùå Failed to generate QR for ${secret.issuer}:${secret.label}:`, error);
      }
    }
    
    return qrCodes;
  }

  /**
   * Generate migration QR codes (Google Authenticator format)
   * @param {Array} secrets - TOTP secrets
   * @returns {Promise<Array>} Array of migration QR data
   */
  async generateMigrationQRs(secrets) {
    const batchSize = 10; // Max secrets per QR (Google Auth limit)
    const qrCodes = [];
    
    // Split secrets into batches
    for (let i = 0; i < secrets.length; i += batchSize) {
      const batch = secrets.slice(i, i + batchSize);
      
      try {
        // Generate migration QR for this batch
        const qrDataUrl = await qrManager.generateMigrationQR(batch);
        
        qrCodes.push({
          type: 'migration',
          secretCount: batch.length,
          batchNumber: Math.floor(i / batchSize) + 1,
          totalBatches: Math.ceil(secrets.length / batchSize),
          qrCode: qrDataUrl,
          secrets: batch.map(s => ({ issuer: s.issuer, label: s.label }))
        });
        
        console.log(`‚úÖ Generated migration QR batch ${qrCodes.length} (${batch.length} secrets)`);
      } catch (error) {
        console.error(`‚ùå Failed to generate migration QR batch ${i}:`, error);
      }
    }
    
    return qrCodes;
  }

  /**
   * Export to JSON backup format (encrypted)
   * @param {Array} secrets - TOTP secrets
   * @param {string} password - Export password
   * @returns {Promise<string>} JSON backup data
   */
  async exportToJSON(secrets, password) {
    try {
      const exportData = {
        version: '1.0',
        type: 'personal-2fa-backup',
        timestamp: new Date().toISOString(),
        secretCount: secrets.length,
        secrets: secrets.map(secret => ({
          issuer: secret.issuer,
          label: secret.label,
          secret: secret.secret,
          algorithm: secret.algorithm,
          digits: secret.digits,
          period: secret.period
        }))
      };
      
      // If password provided, encrypt the backup
      if (password) {
        // This would use the crypto module to encrypt the JSON
        // For now, return plain JSON (in production, encrypt this)
        console.log('üîê TODO: Encrypt backup with password');
      }
      
      return JSON.stringify(exportData, null, 2);
    } catch (error) {
      throw new Error(`JSON export failed: ${error.message}`);
    }
  }

  /**
   * Import from JSON backup format
   * @param {string} jsonData - JSON backup data
   * @param {string} password - Decryption password (if encrypted)
   * @returns {Promise<Array>} Array of TOTP secrets
   */
  async importFromJSON(jsonData, password) {
    try {
      // If password provided, decrypt the backup
      if (password) {
        console.log('üîì TODO: Decrypt backup with password');
        // This would use the crypto module to decrypt
      }
      
      const backupData = JSON.parse(jsonData);
      
      if (backupData.type !== 'personal-2fa-backup') {
        throw new Error('Invalid backup format');
      }
      
      if (!backupData.secrets || !Array.isArray(backupData.secrets)) {
        throw new Error('No secrets found in backup');
      }
      
      // Validate each secret
      const validatedSecrets = [];
      for (const secret of backupData.secrets) {
        try {
          const validated = await this.validateTOTPSecret(secret);
          validatedSecrets.push(validated);
        } catch (error) {
          console.warn(`‚ö†Ô∏è Skipping invalid secret in backup:`, error.message);
        }
      }
      
      console.log(`‚úÖ Imported ${validatedSecrets.length} secrets from JSON backup`);
      return validatedSecrets;
    } catch (error) {
      throw new Error(`JSON import failed: ${error.message}`);
    }
  }

  /**
   * Validate TOTP secret configuration
   * @param {Object} secret - TOTP secret to validate
   * @returns {Promise<Object>} Validated and normalized secret
   */
  async validateTOTPSecret(secret) {
    const { issuer, label, secret: secretKey, algorithm, digits, period } = secret;
    
    // Required fields
    if (!secretKey || !label) {
      throw new Error('Secret and label are required');
    }
    
    // Validate Base32 secret
    if (!totpGenerator.isValidBase32(secretKey)) {
      throw new Error('Invalid Base32 secret');
    }
    
    // Normalize and validate algorithm
    const normalizedAlgorithm = (algorithm || 'SHA1').toUpperCase();
    if (!['SHA1', 'SHA256', 'SHA512'].includes(normalizedAlgorithm)) {
      throw new Error(`Unsupported algorithm: ${algorithm}`);
    }
    
    // Validate digits
    const normalizedDigits = parseInt(digits) || 6;
    if (![6, 8].includes(normalizedDigits)) {
      throw new Error(`Invalid digits count: ${digits}`);
    }
    
    // Validate period
    const normalizedPeriod = parseInt(period) || 30;
    if (normalizedPeriod < 15 || normalizedPeriod > 300) {
      throw new Error(`Invalid period: ${period}`);
    }
    
    // Test secret by generating a TOTP code
    try {
      await totpGenerator.generateTOTP(secretKey, {
        algorithm: normalizedAlgorithm,
        digits: normalizedDigits,
        period: normalizedPeriod
      });
    } catch (error) {
      throw new Error(`Secret validation failed: ${error.message}`);
    }
    
    return {
      issuer: issuer || 'Unknown',
      label: label.trim(),
      secret: secretKey.toUpperCase().replace(/\s/g, ''),
      algorithm: normalizedAlgorithm,
      digits: normalizedDigits,
      period: normalizedPeriod
    };
  }

  /**
   * Add secret for export-only mode (temporary storage)
   * These secrets are NOT stored permanently, only held for export
   * @param {Object} secret - TOTP secret configuration
   */
  addSecretForExport(secret) {
    console.log('üìù Adding secret for export-only mode (not storing permanently)');
    
    // Add to temporary export list
    this.exportedSecrets.push({
      ...secret,
      addedAt: new Date().toISOString()
    });
    
    console.log(`üì§ Export queue now has ${this.exportedSecrets.length} secrets`);
  }

  /**
   * Get secrets in export-only mode
   * @returns {Array} Current export-only secrets
   */
  getExportOnlySecrets() {
    return [...this.exportedSecrets];
  }

  /**
   * Clear export-only secrets
   */
  clearExportOnlySecrets() {
    console.log('üóëÔ∏è Clearing export-only secrets queue');
    this.exportedSecrets = [];
  }

  /**
   * Check compatibility with different authenticator apps
   * @param {Object} secret - TOTP secret
   * @returns {Object} Compatibility information
   */
  checkCompatibility(secret) {
    const compatibility = {
      googleAuth: true, // Always compatible
      microsoftAuth: true,
      authy: false, // Authy doesn't support standard imports
      aegis: true,
      andOTP: true,
      lastpass: secret.algorithm === 'SHA1' && secret.digits === 6, // Limited support
      bitwarden: true
    };
    
    // Check specific limitations
    if (secret.algorithm !== 'SHA1') {
      compatibility.lastpass = false;
    }
    
    if (secret.digits !== 6) {
      compatibility.lastpass = false;
    }
    
    if (secret.period !== 30) {
      compatibility.lastpass = false;
      compatibility.microsoftAuth = false;
    }
    
    return {
      compatible: compatibility,
      warnings: this.getCompatibilityWarnings(secret, compatibility)
    };
  }

  /**
   * Get compatibility warnings for a secret
   * @param {Object} secret - TOTP secret
   * @param {Object} compatibility - Compatibility info
   * @returns {Array} Array of warning messages
   */
  getCompatibilityWarnings(secret, compatibility) {
    const warnings = [];
    
    if (secret.algorithm !== 'SHA1') {
      warnings.push('Non-SHA1 algorithms may not work with all authenticator apps');
    }
    
    if (secret.digits !== 6) {
      warnings.push('8-digit codes may not be supported by all apps');
    }
    
    if (secret.period !== 30) {
      warnings.push('Non-standard periods may not work with all apps');
    }
    
    const incompatibleApps = Object.entries(compatibility)
      .filter(([app, isCompatible]) => !isCompatible)
      .map(([app]) => app);
    
    if (incompatibleApps.length > 0) {
      warnings.push(`Not compatible with: ${incompatibleApps.join(', ')}`);
    }
    
    return warnings;
  }
}

// Export singleton instance
const googleAuthManager = new GoogleAuthManager();
  // Export to global scope
  window.GoogleAuthManager = GoogleAuthManager;
  window.googleAuthManager = googleAuthManager;

})();


/* ============= main.js ============= */
(function() {
  'use strict';
  
/**
 * Main Application Controller
 * Coordinates all modules and manages application state
 */

class Personal2FAApp {
  constructor() {
    this.currentScreen = 'setup';
    this.isUnlocked = false;
    this.totpTimers = new Map();
    this.refreshInterval = null;
    this.securityCheckInterval = null;
    
    // DOM elements will be initialized in init()
    this.elements = {};
  }

  /**
   * Initialize the application
   */
  async init() {
    console.log('üöÄ Initializing Personal 2FA App...');
    
    try {
      // Initialize storage
      await storageManager.init();
      
      // Cache DOM elements
      this.initDOMElements();
      
      // Setup event listeners
      this.setupEventListeners();
      
      // Initialize QR manager
      qrManager.init(this.elements.qrVideo, this.elements.qrCanvas);
      
      // Check security status
      this.performSecurityChecks();
      
      // Determine initial screen
      const isSetup = await storageManager.isSetup();
      if (isSetup) {
        this.showScreen('login');
      } else {
        this.showScreen('setup');
      }
      
      console.log('‚úÖ App initialization complete');
      
    } catch (error) {
      console.error('‚ùå App initialization failed:', error);
      this.showError('Failed to initialize app: ' + error.message);
    }
  }

  /**
   * Cache DOM elements for performance
   */
  initDOMElements() {
    this.elements = {
      // Screens
      setupScreen: document.getElementById('setup-screen'),
      loginScreen: document.getElementById('login-screen'),
      mainScreen: document.getElementById('main-screen'),
      
      // Setup elements
      masterPassword: document.getElementById('master-password'),
      confirmPassword: document.getElementById('confirm-password'),
      setupComplete: document.getElementById('setup-complete'),
      
      // Login elements
      loginPassword: document.getElementById('login-password'),
      loginBtn: document.getElementById('login-btn'),
      loginError: document.getElementById('login-error'),
      
      // Main app elements
      importBtn: document.getElementById('import-btn'),
      exportBtn: document.getElementById('export-btn'),
      addManualBtn: document.getElementById('add-manual-btn'),
      lockBtn: document.getElementById('lock-btn'),
      
      // Sections
      importSection: document.getElementById('import-section'),
      exportSection: document.getElementById('export-section'),
      codesSection: document.getElementById('codes-section'),
      manualAddSection: document.getElementById('manual-add-section'),
      
      // QR Scanner
      qrVideo: document.getElementById('qr-video'),
      qrCanvas: document.getElementById('qr-canvas'),
      startCamera: document.getElementById('start-camera'),
      stopCamera: document.getElementById('stop-camera'),
      scanResult: document.getElementById('scan-result'),
      
      // Export
      exportGoogleFormat: document.getElementById('export-google-format'),
      exportIndividualQR: document.getElementById('export-individual-qr'),
      exportJSONBackup: document.getElementById('export-json-backup'),
      exportResult: document.getElementById('export-result'),
      
      // TOTP Display
      totpList: document.getElementById('totp-list'),
      emptyState: document.getElementById('empty-state'),
      
      // Manual Add Form
      manualAddForm: document.getElementById('manual-add-form'),
      manualIssuer: document.getElementById('manual-issuer'),
      manualLabel: document.getElementById('manual-label'),
      manualSecret: document.getElementById('manual-secret'),
      manualAlgorithm: document.getElementById('manual-algorithm'),
      manualDigits: document.getElementById('manual-digits'),
      manualPeriod: document.getElementById('manual-period'),
      cancelManual: document.getElementById('cancel-manual'),
      
      // Security indicators
      cryptoStatus: document.getElementById('crypto-status'),
      storageStatus: document.getElementById('storage-status'),
      networkStatus: document.getElementById('network-status'),
      securityChecks: document.getElementById('security-checks')
    };
  }

  /**
   * Setup all event listeners
   */
  setupEventListeners() {
    // Setup screen
    this.elements.setupComplete.addEventListener('click', () => this.handleSetup());
    
    // Login screen
    this.elements.loginBtn.addEventListener('click', () => this.handleLogin());
    this.elements.loginPassword.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') this.handleLogin();
    });
    
    // Main navigation
    this.elements.importBtn.addEventListener('click', () => this.showImportSection());
    this.elements.exportBtn.addEventListener('click', () => this.showExportSection());
    this.elements.addManualBtn.addEventListener('click', () => this.showManualAddSection());
    this.elements.lockBtn.addEventListener('click', () => this.lockApp());
    
    // QR Scanner
    this.elements.startCamera.addEventListener('click', () => this.startQRScanning());
    this.elements.stopCamera.addEventListener('click', () => this.stopQRScanning());
    
    // Export buttons
    this.elements.exportGoogleFormat.addEventListener('click', () => this.exportGoogleFormat());
    this.elements.exportIndividualQR.addEventListener('click', () => this.exportIndividualQR());
    this.elements.exportJSONBackup.addEventListener('click', () => this.exportJSONBackup());
    
    // Manual add form
    this.elements.manualAddForm.addEventListener('submit', (e) => this.handleManualAdd(e));
    this.elements.cancelManual.addEventListener('click', () => this.hideAllSections());
    
    // Network status monitoring
    window.addEventListener('online', () => this.updateNetworkStatus());
    window.addEventListener('offline', () => this.updateNetworkStatus());
    
    // Security monitoring
    this.startSecurityMonitoring();
  }

  /**
   * Handle master password setup
   */
  async handleSetup() {
    const password = this.elements.masterPassword.value;
    const confirmPassword = this.elements.confirmPassword.value;
    
    if (!password || password.length < 8) {
      this.showError('Password must be at least 8 characters long');
      return;
    }
    
    if (password !== confirmPassword) {
      this.showError('Passwords do not match');
      return;
    }
    
    try {
      console.log('üîê Setting up master password...');
      await storageManager.setupMasterPassword(password);
      this.isUnlocked = true;
      this.showScreen('main');
      this.refreshTOTPCodes();
      console.log('‚úÖ Master password setup complete');
    } catch (error) {
      console.error('‚ùå Setup failed:', error);
      this.showError('Setup failed: ' + error.message);
    }
  }

  /**
   * Handle login with master password
   */
  async handleLogin() {
    const password = this.elements.loginPassword.value;
    
    if (!password) {
      this.showLoginError('Please enter your master password');
      return;
    }
    
    try {
      console.log('üîì Attempting to unlock storage...');
      const success = await storageManager.unlock(password);
      
      if (success) {
        this.isUnlocked = true;
        this.showScreen('main');
        this.refreshTOTPCodes();
        console.log('‚úÖ Storage unlocked successfully');
      } else {
        this.showLoginError('Invalid password');
      }
    } catch (error) {
      console.error('‚ùå Login failed:', error);
      this.showLoginError('Login failed: ' + error.message);
    }
  }

  /**
   * Show import section and hide others
   */
  showImportSection() {
    this.hideAllSections();
    this.elements.importSection.classList.remove('hidden');
  }

  /**
   * Show export section and hide others
   */
  showExportSection() {
    this.hideAllSections();
    this.elements.exportSection.classList.remove('hidden');
  }

  /**
   * Show manual add section and hide others
   */
  showManualAddSection() {
    this.hideAllSections();
    this.elements.manualAddSection.classList.remove('hidden');
  }

  /**
   * Hide all sections
   */
  hideAllSections() {
    const sections = [
      this.elements.importSection,
      this.elements.exportSection,
      this.elements.manualAddSection
    ];
    
    sections.forEach(section => section.classList.add('hidden'));
  }

  /**
   * Start QR code scanning
   */
  async startQRScanning() {
    try {
      console.log('üìπ Starting QR scanner...');
      
      this.elements.startCamera.classList.add('hidden');
      this.elements.stopCamera.classList.remove('hidden');
      this.elements.scanResult.innerHTML = '<div class="scanning">üîç Scanning for QR codes...</div>';
      
      await qrManager.startScanning((qrData) => {
        this.handleQRDetected(qrData);
      });
      
    } catch (error) {
      console.error('‚ùå Failed to start camera:', error);
      this.elements.scanResult.innerHTML = `<div class="error">‚ùå Camera Error: ${error.message}</div>`;
      this.elements.startCamera.classList.remove('hidden');
      this.elements.stopCamera.classList.add('hidden');
    }
  }

  /**
   * Stop QR code scanning
   */
  stopQRScanning() {
    console.log('‚èπÔ∏è Stopping QR scanner...');
    
    qrManager.stopScanning();
    this.elements.startCamera.classList.remove('hidden');
    this.elements.stopCamera.classList.add('hidden');
    this.elements.scanResult.innerHTML = '';
  }

  /**
   * Handle detected QR code
   */
  async handleQRDetected(qrData) {
    try {
      console.log('üîç QR Code detected:', qrData);
      
      // Stop scanning
      this.stopQRScanning();
      
      // Check if it's a migration QR
      if (qrData.startsWith('otpauth-migration://')) {
        console.log('üì± Google Authenticator migration QR detected');
        const secrets = await googleAuthManager.importFromGoogleAuth(qrData);
        await this.importTOTPSecrets(secrets);
      } else if (qrData.startsWith('otpauth://')) {
        console.log('üîë Individual TOTP QR detected');
        const secret = totpGenerator.parseOTPAuthURI(qrData);
        await this.importTOTPSecrets([secret]);
      } else {
        throw new Error('Unrecognized QR code format');
      }
      
    } catch (error) {
      console.error('‚ùå QR processing failed:', error);
      this.elements.scanResult.innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
    }
  }

  /**
   * Import TOTP secrets and store them
   */
  async importTOTPSecrets(secrets) {
    try {
      let importedCount = 0;
      
      for (const secret of secrets) {
        try {
          await storageManager.storeTOTPSecret(secret);
          importedCount++;
          console.log(`‚úÖ Imported: ${secret.issuer}:${secret.label}`);
        } catch (error) {
          console.error(`‚ùå Failed to import ${secret.issuer}:${secret.label}:`, error);
        }
      }
      
      this.elements.scanResult.innerHTML = `
        <div class="success">
          ‚úÖ Successfully imported ${importedCount} TOTP secrets!
        </div>
      `;
      
      // Refresh the TOTP display
      this.refreshTOTPCodes();
      
    } catch (error) {
      console.error('‚ùå Import failed:', error);
      this.elements.scanResult.innerHTML = `<div class="error">‚ùå Import failed: ${error.message}</div>`;
    }
  }

  /**
   * Handle manual TOTP addition
   */
  async handleManualAdd(event) {
    event.preventDefault();
    
    const secret = {
      issuer: this.elements.manualIssuer.value.trim(),
      label: this.elements.manualLabel.value.trim(),
      secret: this.elements.manualSecret.value.trim(),
      algorithm: this.elements.manualAlgorithm.value,
      digits: parseInt(this.elements.manualDigits.value),
      period: parseInt(this.elements.manualPeriod.value)
    };
    
    try {
      // Validate the secret
      const validatedSecret = await googleAuthManager.validateTOTPSecret(secret);
      
      // Store the secret
      await storageManager.storeTOTPSecret(validatedSecret);
      
      console.log(`‚úÖ Added manual TOTP: ${secret.issuer}:${secret.label}`);
      
      // Reset form and hide section
      this.elements.manualAddForm.reset();
      this.hideAllSections();
      
      // Refresh display
      this.refreshTOTPCodes();
      
    } catch (error) {
      console.error('‚ùå Manual add failed:', error);
      this.showError('Failed to add TOTP: ' + error.message);
    }
  }

  /**
   * Export in Google Authenticator format
   */
  async exportGoogleFormat() {
    try {
      const secrets = await storageManager.getAllTOTPSecrets();
      const qrCodes = await googleAuthManager.generateExportQRs(secrets, 'migration');
      this.displayExportResult(qrCodes, 'Google Authenticator Migration');
    } catch (error) {
      console.error('‚ùå Google format export failed:', error);
      this.showError('Export failed: ' + error.message);
    }
  }

  /**
   * Export individual QR codes
   */
  async exportIndividualQR() {
    try {
      const secrets = await storageManager.getAllTOTPSecrets();
      const qrCodes = await googleAuthManager.generateExportQRs(secrets, 'individual');
      this.displayExportResult(qrCodes, 'Individual QR Codes');
    } catch (error) {
      console.error('‚ùå Individual QR export failed:', error);
      this.showError('Export failed: ' + error.message);
    }
  }

  /**
   * Export JSON backup
   */
  async exportJSONBackup() {
    try {
      const secrets = await storageManager.getAllTOTPSecrets();
      const jsonBackup = await googleAuthManager.exportToJSON(secrets);
      
      // Create download link
      const blob = new Blob([jsonBackup], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `personal-2fa-backup-${new Date().toISOString().split('T')[0]}.json`;
      link.click();
      
      URL.revokeObjectURL(url);
      
      this.elements.exportResult.innerHTML = '<div class="success">‚úÖ JSON backup downloaded!</div>';
      
    } catch (error) {
      console.error('‚ùå JSON export failed:', error);
      this.showError('Export failed: ' + error.message);
    }
  }

  /**
   * Display export results
   */
  displayExportResult(qrCodes, title) {
    let html = `<h4>${title}</h4>`;
    
    qrCodes.forEach((qr, index) => {
      html += `
        <div class="export-qr">
          <h5>${qr.type === 'individual' ? `${qr.issuer}: ${qr.label}` : `Batch ${qr.batchNumber}/${qr.totalBatches}`}</h5>
          <img src="${qr.qrCode}" alt="QR Code" style="max-width: 300px;">
        </div>
      `;
    });
    
    this.elements.exportResult.innerHTML = html;
  }

  /**
   * Refresh TOTP codes display
   */
  async refreshTOTPCodes() {
    try {
      const secrets = await storageManager.getAllTOTPSecrets();
      
      if (secrets.length === 0) {
        this.elements.totpList.style.display = 'none';
        this.elements.emptyState.style.display = 'block';
        return;
      }
      
      this.elements.totpList.style.display = 'block';
      this.elements.emptyState.style.display = 'none';
      
      // Clear existing timers
      this.totpTimers.clear();
      
      // Generate HTML for each TOTP
      let html = '';
      for (const secret of secrets) {
        const totpData = await totpGenerator.generateTOTP(secret.secret, secret);
        html += this.createTOTPItemHTML(secret, totpData);
        
        // Store timer info
        this.totpTimers.set(secret.id, {
          secret,
          lastUpdate: Date.now()
        });
      }
      
      this.elements.totpList.innerHTML = html;
      
      // Start refresh timer
      this.startTOTPRefresh();
      
    } catch (error) {
      console.error('‚ùå Failed to refresh TOTP codes:', error);
      this.showError('Failed to load TOTP codes: ' + error.message);
    }
  }

  /**
   * Create HTML for TOTP item
   */
  createTOTPItemHTML(secret, totpData) {
    return `
      <div class="totp-item" data-id="${secret.id}">
        <div class="totp-header">
          <div class="totp-service">${secret.issuer}</div>
          <div class="totp-account">${secret.label}</div>
        </div>
        <div class="totp-code" onclick="navigator.clipboard.writeText('${totpData.code}')">${totpData.code}</div>
        <div class="totp-timer">
          <div class="timer-progress">
            <div class="timer-bar" style="width: ${totpData.progress}%"></div>
          </div>
          <div class="timer-text">${totpData.timeRemaining}s</div>
        </div>
      </div>
    `;
  }

  /**
   * Start TOTP refresh timer
   */
  startTOTPRefresh() {
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
    }
    
    this.refreshInterval = setInterval(() => {
      this.updateTOTPTimers();
    }, 1000);
  }

  /**
   * Update TOTP timers and regenerate codes when needed
   */
  async updateTOTPTimers() {
    for (const [secretId, timerInfo] of this.totpTimers) {
      try {
        const totpData = await totpGenerator.generateTOTP(timerInfo.secret.secret, timerInfo.secret);
        
        const element = document.querySelector(`[data-id="${secretId}"]`);
        if (element) {
          // Update code if it changed
          const codeElement = element.querySelector('.totp-code');
          if (codeElement.textContent !== totpData.code) {
            codeElement.textContent = totpData.code;
          }
          
          // Update timer
          const timerBar = element.querySelector('.timer-bar');
          const timerText = element.querySelector('.timer-text');
          
          if (timerBar && timerText) {
            timerBar.style.width = `${totpData.progress}%`;
            timerText.textContent = `${totpData.timeRemaining}s`;
          }
        }
      } catch (error) {
        console.error(`‚ùå Failed to update TOTP for secret ${secretId}:`, error);
      }
    }
  }

  /**
   * Lock the application
   */
  lockApp() {
    console.log('üîí Locking application...');
    
    // Clear timers
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
      this.refreshInterval = null;
    }
    
    this.totpTimers.clear();
    
    // Lock storage
    storageManager.lock();
    this.isUnlocked = false;
    
    // Clear sensitive data from DOM
    this.elements.totpList.innerHTML = '';
    this.elements.loginPassword.value = '';
    
    // Show login screen
    this.showScreen('login');
  }

  /**
   * Show specific screen
   */
  showScreen(screenName) {
    const screens = ['setup', 'login', 'main'];
    
    screens.forEach(screen => {
      const element = document.getElementById(`${screen}-screen`);
      if (element) {
        element.classList.toggle('active', screen === screenName);
      }
    });
    
    this.currentScreen = screenName;
    console.log(`üì± Showing ${screenName} screen`);
  }

  /**
   * Show error message
   */
  showError(message) {
    console.error('‚ùå', message);
    // TODO: Implement proper error display
    alert(message);
  }

  /**
   * Show login error
   */
  showLoginError(message) {
    this.elements.loginError.textContent = message;
    this.elements.loginError.classList.add('show');
    
    setTimeout(() => {
      this.elements.loginError.classList.remove('show');
    }, 5000);
  }

  /**
   * Perform security checks
   */
  performSecurityChecks() {
    const status = cryptoManager.getSecurityStatus();
    
    // Update security indicators
    this.elements.cryptoStatus.textContent = status.isSecure ? 'üîê Cifrado: AES-256' : '‚ö†Ô∏è Cifrado: No disponible';
    this.elements.storageStatus.textContent = 'üè† Local';
    this.updateNetworkStatus();
    
    // Display detailed security checks
    const checksHtml = Object.entries(status)
      .map(([key, value]) => `<div>${key}: ${value ? '‚úÖ' : '‚ùå'}</div>`)
      .join('');
    
    this.elements.securityChecks.innerHTML = checksHtml;
    
    if (!status.isSecure) {
      this.showError('Security warning: Web Crypto API not available. Please use HTTPS or localhost.');
    }
  }

  /**
   * Update network status indicator
   */
  updateNetworkStatus() {
    const isOnline = navigator.onLine;
    this.elements.networkStatus.textContent = isOnline ? 'üì° Online ‚ö†Ô∏è' : 'üì° Offline ‚úÖ';
    this.elements.networkStatus.className = `indicator ${isOnline ? 'warning' : 'secure'}`;
  }

  /**
   * Start security monitoring
   */
  startSecurityMonitoring() {
    this.securityCheckInterval = setInterval(() => {
      this.performSecurityChecks();
    }, 30000); // Check every 30 seconds
  }
}

// Initialize app when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  const app = new Personal2FAApp();
  app.init();
  
  // Make app globally available for debugging
  window.Personal2FA = app;
});

})();


/* ============= Initialization ============= */
// Initialize app when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
  console.log('üöÄ Personal 2FA starting...');
  
  // App will be initialized by main.js
  if (typeof Personal2FAApp !== 'undefined') {
    const app = new Personal2FAApp();
    app.init();
    window.Personal2FA = app;
  }
});

</script>
</body>
</html>